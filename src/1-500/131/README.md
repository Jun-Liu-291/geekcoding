# 题目
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]

# 级别 
High

# 算法口号
用二维数组存字符串i到j是不是回文，遍历所有的i，j

# 解题思路
这是我本轮刷题第一个动态规划题。思路就是记录每一对从i到j的字符串是不是回文，以避免重复计算
循环方法是先j从0到len - 1，然后每长一格都用i来搜索所有0-j + 1里面有没有回文(之所以是j+1是因为本身单个字符也是回文)，有的话就记录在dp矩阵当中。<p>
rst(result)矩阵是另一个记录矩阵，记录的是当字符串长度为i时候的最后结果。这其实才是真正的动态规划的常用方法
<p>第一步，当j = 0的时候，那什么都没有，就是空。<br>
第二步，当j = 1的时候，那么字符串就是a。a的回文就是它本身。<br>
第三步， 当 j = 2的时候，字符串aa，结果就是原来所有的回文的结果（上一步的结果，加上它自己），于是得到'a', 'a'。再加入i 从 0 到 j 的检查结果'aa'也是回文。于是得到新的答案。
<br>
以此类推，最后得到所有的结果。但输出只输出最后j等于整个字符串长度时候的结果。

<p>
另外这道题目对数组的操作非常经典，如何开数组？初始化数组？打印数组？大家请关注
</p>

# 算法归类
<a href="../../../DP.md">动态规划</a>